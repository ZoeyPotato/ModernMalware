using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class Player : MonoBehaviour
{
    public class Quest
    {
        public GameObject npc;
        // Quest id is relative to a gameobject npc
        public int questId;
        public NpcQuestBase quest;
        public int count;
    };
    // This will be a sorted list by quest id
    public List<Quest> quests = new List<Quest>();
    public int collectedItems = 0;
    public int enemiesKilled = 0;

    public enum PlayerDirectionState
    {
        kLeft = 0,
        kRight = 1,
        kUp = 2,
        kDown = 3
    };

    public enum MouseDirectionState
    {
        kLeft = 0,
        kRight = 1,
        kUp = 2,
        kDown = 3
    };

    public enum AttackState
    {
        kNotAttacking = 0,
        kCharging = 1,
        kMeleeAttack = 2
    };

    public int TotalHitPoints = 3;   //total number of hit points/life
    public static int CurHitPoints { get; set; }  //current number of hit points   

    //START OF COMBAT VARIABLES
    //public int AttackDamage = 1;   //how much damage to deal per attack

    //public float AttackCD = 1.5f;   //total amount of time to wait between attacks
    //private float curAttackCD;   //amount of time passed since last attack

    public static string playerName = "Player";
    public static Color playerColor = Color.white;
    private float shootCooldown;
    public float shootingRate = 0.5f;
    //END OF COMBAT VARIABLES

    private const float defaultSpeed = 5.0f;   //variable runtime Speed
    public float Speed = defaultSpeed;
    
    public static Player Instance;	
    public GameObject projectilePrefab = null;    
    private Animator animation = null;
    public bool isBlocking = false;
    private bool blockResetFlag = false;
    
    public PlayerDirectionState directionState = PlayerDirectionState.kDown;
    public MouseDirectionState mouseDirection = MouseDirectionState.kDown;

    public static Vector3 leftDirection = new Vector3(-1.0f, 0.0f, 0.0f);
    public static Vector3 rightDirection = new Vector3(1.0f, 0.0f, 0.0f);
    public static Vector3 upDirection = new Vector3(0.0f, 1.0f, 0.0f);
    public static Vector3 downDirection = new Vector3(0.0f, -1.0f, 0.0f);

    public AttackState attackState = AttackState.kNotAttacking;
    public bool canMeleeAttack = true;

    public int questsCompleted = 0;

	#region Collision
	private Vector3 newPos;
	private float topMax, botMax, rightMax, leftMax;
	private bool topC, botC, rightC, leftC = false; 
	public bool collided;
	#endregion

    void Start ()
    {
        // Only for our player, first instantiation of player
        if (Instance == null)
        {
            Instance = this;
            CurHitPoints = TotalHitPoints;
        }

        if (animation == null)
            animation = this.GetComponent<Animator>();

        shootCooldown = 0.0f;        
	}

    private bool rangedReady = false;
    private float chargeTimeSoFar = 0.0f;
    private float maximumChargeTime = 1.0f;
    private const float kMaximumProjectileDistance = 20.0f;
    public float maximumProjectileDamage = 5.0f;
    private static Vector3 upperLeftDirection = new Vector3(-Mathf.Cos(Mathf.PI / 4), Mathf.Sin(Mathf.PI / 4), 0.0f);
    private static Vector3 upperRightDirection = new Vector3(Mathf.Cos(Mathf.PI / 4), Mathf.Sin(Mathf.PI / 4), 0.0f);
    private static Vector3 lowerLeftDirection = new Vector3(-Mathf.Cos(Mathf.PI / 4), -Mathf.Sin(Mathf.PI / 4), 0.0f);
    private static Vector3 lowerRightDirection = new Vector3(Mathf.Cos(Mathf.PI / 4), -Mathf.Sin(Mathf.PI / 4), 0.0f);
    private float meleeAttackCooldown = 0.0f;
    public float meleeAttackDuration = 0.07f;
    public float meleeAttackPeriod = 0.1f;
    private Vector3 initialMeleeOffset = Vector3.zero;
    public float meleeAttackJutSpeed = 10.0f;
    public bool isBeingAttacked = false;
	void Update ()
    {
        //if we are out of life, die
        //this will later call to the lose screen or whatever, not actually destroy player
        //if (CurHitPoints <= 0)
            //Destroy(this.gameObject);   //comment out if you want to keep testing after player 'dies'
        
        if (this == Instance)
        {
            GetComponent<SpriteRenderer>().color = playerColor;
            projectilePrefab.GetComponent<SpriteRenderer>().color = playerColor;
            GetComponentInChildren<MeleeAttack>().GetComponent<SpriteRenderer>().color = playerColor;
            isBeingAttacked = false;
            for (int i = 0; i < Enemy.enemies.Count; ++i)
            {
                if (Enemy.enemies[i].isAggroed)
                {
                    isBeingAttacked = true;
                    break;
                }
            }
            for (int i = 0; i < quests.Count; ++i)
            {
                if (quests[i].count == quests[i].npc.GetComponent<NpcQuestBase>().targetCount)
                {
                    Debug.Log("Quest completed");
                    SoundEffectsHelper.Instance.MakeQuestCompletedSound();
                    quests[i].quest.gameObject.GetComponent<Animator>().SetBool("IsComplete", true);
                    quests[i].quest.gameObject.GetComponent<KillEnemyQuest>().isCompleted = true;
                    quests.RemoveAt(i);
                    questsCompleted++;
                    i--;
                }
            }

            float verticalAxis = Input.GetAxis("Vertical");
            float horizontalAxis = Input.GetAxis("Horizontal");

            isBlocking = false;
            //if (Input.GetButtonUp("Fire2"))
            //{
            //    Debug.Log("am I repeating?");
            //    isBlocking = false;
            //    blockResetFlag = true;

            //    if (directionState == PlayerDirectionState.kRight)
            //        GoToAniState("Moving_Right");
            //    else if (directionState == PlayerDirectionState.kDown)
            //        GoToAniState("Moving_Down");
            //    else if (directionState == PlayerDirectionState.kUp)
            //        GoToAniState("Moving_Up");
            //    else if (directionState == PlayerDirectionState.kLeft)
            //        GoToAniState("Moving_Left");
            //}

			#region don't move if collided
			newPos = transform.position;
            newPos += verticalAxis * transform.up * (Speed * Time.smoothDeltaTime);
            newPos += horizontalAxis * transform.right * (Speed * Time.smoothDeltaTime);
			if(collided){
				checkCollision();
				transform.localPosition = newPos;
			}else{
				topC = botC = rightC = leftC = false;
				topMax = botMax = rightMax = leftMax = 0f;
				transform.localPosition = newPos;
			}

			#endregion

            //Debug.Log("Shoot cd: " + shootCooldown);
            if (shootCooldown > 0)
                shootCooldown -= Time.deltaTime;

            if (attackState == AttackState.kMeleeAttack)
            {

                if (meleeAttackCooldown > 0)
                {
                    //Debug.Log("In melee: " + meleeAttackCooldown);
                    meleeAttackCooldown -= Time.deltaTime;
                    GetComponentInChildren<MeleeAttack>().gameObject.transform.localPosition += GetComponentInChildren<MeleeAttack>().transform.up * (meleeAttackJutSpeed * Time.smoothDeltaTime);
                    if (meleeAttackCooldown > meleeAttackDuration)
                        canMeleeAttack = false;
                }
                else
                {
                    //Debug.Log("Finished melee");
                    GetComponentInChildren<MeleeAttack>().gameObject.transform.localPosition = Vector3.zero;
                    canMeleeAttack = true;
                    attackState = AttackState.kNotAttacking;
                }
            }
            else
            {

                if (Input.GetKey(KeyCode.LeftShift))
                {
                    if (Input.GetButtonUp("Fire1"))
                    {
                        attackState = AttackState.kCharging;
                        Debug.Log("Shift + Fire");
                        TryToAttack(Input.mousePosition);
                        chargeTimeSoFar = 0.0f;
                        attackState = AttackState.kNotAttacking;
                    }
                    else if (Input.GetButton("Fire1"))
                    {
                        attackState = AttackState.kCharging;
                        chargeTimeSoFar += Time.deltaTime;
						chargeTimeSoFar = Mathf.Min (chargeTimeSoFar, 1);
                    }
                    else
                    {
                        attackState = AttackState.kNotAttacking;
                        chargeTimeSoFar = 0.0f;
                    }
                }
                else if (Input.GetButtonUp("Fire1") || Input.GetButton("Fire2")) // attack and block
                {
                    animation.enabled = true;
                    Vector3 playerPositionOnScreen = Camera.main.WorldToScreenPoint(transform.position);
                    Vector3 mousePositon = Input.mousePosition;
                    mousePositon.z = 0.0f;
                    playerPositionOnScreen.y = Screen.height - playerPositionOnScreen.y;
                    playerPositionOnScreen.z = 0.0f;
                    Vector3 targetDirection = mousePositon - playerPositionOnScreen;
                    targetDirection.Normalize(); // B

                    if ((lowerRightDirection.y * targetDirection.x - lowerRightDirection.x * targetDirection.y) * (lowerRightDirection.y * upperRightDirection.x - lowerRightDirection.x * upperRightDirection.y) >= 0 &&
                        (upperRightDirection.y * targetDirection.x - upperRightDirection.x * targetDirection.y) * (upperRightDirection.y * lowerRightDirection.x - upperRightDirection.x * lowerRightDirection.y) >= 0)
                    {
                        // right
                        if (Input.GetButtonUp("Fire1"))
                        {
                            attackState = AttackState.kMeleeAttack;
                            meleeAttackCooldown = meleeAttackPeriod;
                            GetComponentInChildren<MeleeAttack>().transform.up = rightDirection;
                        }
                        else
                        {
                            mouseDirection = MouseDirectionState.kRight;
                            GoToAniState("Block_Right");
                            isBlocking = true;
                        }
                    }
                    else if ((upperLeftDirection.y * targetDirection.x - upperLeftDirection.x * targetDirection.y) * (upperLeftDirection.y * upperRightDirection.x - upperLeftDirection.x * upperRightDirection.y) >= 0)
                    {
                        // up
                        if (Input.GetButtonUp("Fire1"))
                        {
                            attackState = AttackState.kMeleeAttack;
                            meleeAttackCooldown = meleeAttackPeriod;
                            GetComponentInChildren<MeleeAttack>().transform.up = upDirection;
                        }
                        else
                        {
                            mouseDirection = MouseDirectionState.kUp;
                            GoToAniState("Block_Up");
                            isBlocking = true;
                        }
                        
                    }
                    else if ((lowerLeftDirection.y * targetDirection.x - lowerLeftDirection.x * targetDirection.y) * (lowerLeftDirection.y * lowerRightDirection.x - lowerLeftDirection.x * lowerRightDirection.y) >= 0)
                    {
                        // down
                        if (Input.GetButtonUp("Fire1"))
                        {
                            attackState = AttackState.kMeleeAttack;
                            meleeAttackCooldown = meleeAttackPeriod;
                            GetComponentInChildren<MeleeAttack>().transform.up = downDirection;
                        }
                        else
                        {
                            mouseDirection = MouseDirectionState.kDown;
                            GoToAniState("Block_Down");
                            isBlocking = true;
                        }
                    }
                    else if ((lowerLeftDirection.y * targetDirection.x - lowerLeftDirection.x * targetDirection.y) * (lowerLeftDirection.y * upperLeftDirection.x - lowerLeftDirection.x * upperLeftDirection.y) >= 0)
                    {
                        // left
                        if (Input.GetButtonUp("Fire1"))
                        {
                            attackState = AttackState.kMeleeAttack;
                            meleeAttackCooldown = meleeAttackPeriod;
                            GetComponentInChildren<MeleeAttack>().transform.up = leftDirection;
                        }
                        else
                        {
                            mouseDirection = MouseDirectionState.kLeft;
                            GoToAniState("Block_Left");
                            isBlocking = true;
                        }
                    }
                }
                else
                {
                    attackState = AttackState.kNotAttacking;
                    chargeTimeSoFar = 0.0f;
                }

                if (attackState == AttackState.kCharging)
                {
                    Speed = defaultSpeed * 0.5f;
                }
                else if (attackState == AttackState.kNotAttacking)
                {
                    Speed = defaultSpeed;
                }
            }

            //pick which animation to draw based upon which direction the user is going
            //if the user is going (Up or Down) AND (Left or Right), this code will 
            //draw the Left or Right ani and NOT draw Up or Down.
            animation.enabled = true;

            if (!isBlocking)
            {
                if (horizontalAxis > 0)   //moving right
                {
                    directionState = PlayerDirectionState.kRight;
                    GoToAniState("Moving_Right");
                }
                else if (horizontalAxis < 0)   //moving left
                {
                    directionState = PlayerDirectionState.kLeft;
                    GoToAniState("Moving_Left");
                }
                else if (verticalAxis > 0)   //moving up
                {
                    directionState = PlayerDirectionState.kUp;
                    GoToAniState("Moving_Up");
                }
                else if (verticalAxis < 0)   //moving down
                {
                    directionState = PlayerDirectionState.kDown;
                    GoToAniState("Moving_Down");
                }
                else
                {
                    animation.enabled = false;
                    //animation.enabled = blockResetFlag; //not moving, don't animate movement
                    //Debug.Log("am I donig stuff" + blockResetFlag);
                    //blockResetFlag = false;
                }
            }

            UpdateAttackAnimations();
        }
	}

    private void GoToAniState(string AniState)
    {
        //get the animation state info from the 'Base' layer (layer 0)
        AnimatorStateInfo curAniBaseState = animation.GetCurrentAnimatorStateInfo(0);

        //prepend 'Base.' to passed string. Assumes the state is in 'Base' layer
        string AniStateInBase = "Base." + AniState;

        //if the current ani state of the base doesn't match what we want to go to
        //then we will trigger and go to that state
        if (curAniBaseState.IsName(AniStateInBase) == false)                    
            animation.SetTrigger(AniState);        

        //if we are already in the state we want to go to, we do nothing
        //this lets the animation keep looping and playing out
    }

    private void UpdateAttackAnimations()
    {       
        if (attackState == AttackState.kMeleeAttack)
        {
            animation.enabled = true;

            if (directionState == PlayerDirectionState.kRight)
                GoToAniState("Melee_Right");
            else if (directionState == PlayerDirectionState.kLeft)
                GoToAniState("Melee_Left");
            else if (directionState == PlayerDirectionState.kUp)
                GoToAniState("Melee_Up");
            else if (directionState == PlayerDirectionState.kDown)
                GoToAniState("Melee_Down");
            else
                animation.enabled = false;
        }
        else if (attackState == AttackState.kCharging)
        {
            animation.enabled = true;

            if (directionState == PlayerDirectionState.kRight)
                GoToAniState("Ranged_Right");
            else if (directionState == PlayerDirectionState.kLeft)
                GoToAniState("Ranged_Left");
            else if (directionState == PlayerDirectionState.kUp)
                GoToAniState("Ranged_Up");
            else if (directionState == PlayerDirectionState.kDown)
                GoToAniState("Ranged_Down");
            else
                animation.enabled = false;
        }
    }

    public void TryToAttack(Vector3 mousePosition)
    {
        if (CanAttack)
        {
            Vector3 selectionWorldCoordinatePoint = Camera.main.ScreenToWorldPoint(mousePosition);
            shootCooldown = shootingRate;
            SoundEffectsHelper.Instance.MakeFireSound();
            GameObject b = Instantiate(projectilePrefab) as GameObject;
            Projectile bullet = b.GetComponent<Projectile>();
            bullet.fallOffDistance = kMaximumProjectileDistance * (Mathf.Min(chargeTimeSoFar, maximumChargeTime) + 0.1f);
            // 1 to 5 damage
            bullet.GetComponent<Projectile>().Damage = (int)(Mathf.Max((chargeTimeSoFar / maximumChargeTime) * maximumProjectileDamage, 1));
            b.transform.up = new Vector3(
                selectionWorldCoordinatePoint.x - transform.position.x,
                selectionWorldCoordinatePoint.y - transform.position.y, 0.0f);

            b.transform.position = transform.position;
        }
    }

    public bool CanAttack
    {
        get
        {
            return shootCooldown <= 0.0f;
        }
    }

	#region OnTriggerEnter
    void OnTriggerEnter2D(Collider2D other)
    {
		collided = true;
       
        if (other.name == "ProjectileEnemy(Clone)")
        {
            Transform shield = transform.FindChild("Shield");
            
            if (shield == null || !shield.GetComponent<SpriteRenderer>().enabled)
            {
                Debug.Log("Health: " + gameObject.GetComponent<Health>().CurHitPoints);
                SoundEffectsHelper.Instance.MakeHitSound();
                //ProgressBar healthBar = gameObject.GetComponentInChildren<ProgressBar>();
                //healthBar.Decrease();
		        //CurHitPoints -= other.GetComponent<Projectile>().Damage;
                gameObject.GetComponent<Health>().CurHitPoints -= other.GetComponent<Projectile>().Damage;
            }

            Destroy(other.gameObject);
		}
		else if (other.name == "Wall" || other.gameObject.name == "Trojan"
		         || other.gameObject.name == "Spyware" || other.gameObject.name == "CorruptedFile" 
		         || other.gameObject.name == "NPCHouse")
        {
			//can else if or || for any collidable ojbects
			CollideWithObject(ref other);
		}
    }
	#endregion
    
	void checkCollision()
    {
		if(topC && botC)
        {
			if (rightC && newPos.x < rightMax)
            {
				newPos.x = rightMax;
			}
            else 
			if (leftC && newPos.x > leftMax)
            {
				newPos.x = leftMax;
			}
			return;
		}
		if (rightC && leftC)
        {
			if (topC && newPos.y > topMax)
            {
				newPos.y = topMax;
			}
            else 
			if (botC && newPos.y < botMax)
            {
				newPos.y = botMax;
			}
			return;
		}
		if (topC && newPos.y > topMax){
			newPos.y = topMax;
		}
		if (botC && newPos.y < botMax){
			newPos.y = botMax;
		}
		if (rightC && newPos.x < rightMax){
			newPos.x = rightMax;
		}
		if (leftC && newPos.x > leftMax){
			newPos.x = leftMax;
		}
	}

	void CollideWithObject(ref Collider2D other)
    {
		Bounds myBounds = GetComponent<Renderer>().bounds;
		Bounds otherBounds;
		if (other.name == "Wall"){
			otherBounds = other.transform.FindChild("WallRender").GetComponent<SpriteRenderer>().bounds;
		}else{
			otherBounds = other.gameObject.GetComponent<Renderer>().bounds;
		}

		Vector3 newPosition = transform.position;

		float top = (myBounds.max.y - otherBounds.min.y - 0.05f);
		float bot = (otherBounds.max.y - myBounds.min.y - 0.05f);
		float left = (myBounds.max.x - otherBounds.min.x - 0.45f);
		float right = (otherBounds.max.x - myBounds.min.x -0.45f);
		float min = Mathf.Min (top, bot, left, right);
		
		if (min == top){
			//Debug.Log("Hit from below\n" );
			topC = true;
			//if (topMax == 0 || topMax < otherBounds.min.y - myBounds.extents.y)
			topMax = otherBounds.min.y - myBounds.extents.y + 0.05f;
		}if (min == bot){
			//Debug.Log("Hit from above\n");
			botC = true;
			//if (botMax == 0 ||botMax > otherBounds.max.y + myBounds.extents.y)
			botMax = otherBounds.max.y + myBounds.extents.y - 0.05f;
		}if (min == right){
			//Debug.Log("Hit from right\n");
			rightC = true;
			//if (rightMax == 0 || rightMax > otherBounds.max.x + myBounds.extents.x)
			rightMax = otherBounds.max.x + myBounds.extents.x -0.45f;
		}if (min == left){
			//Debug.Log("Hit from left\n");
			leftC = true;
			//if (leftMax == 0 || leftMax < otherBounds.min.x - myBounds.extents.x)
			leftMax = otherBounds.min.x - myBounds.extents.x +0.45f;
		}

	}

    void OnTriggerStay2D(Collider2D other)
    {			
		if (other.name == "Wall" || other.gameObject.name == "Trojan"
            || other.gameObject.name == "Spyware" || other.gameObject.name == "CorruptedFile"
		    || other.gameObject.name == "NPCHouse")
        {
			collided = true;   //can else if or || for any collidable ojbects
			CollideWithObject(ref other);
		}
    }

	void OnTriggerExit2D(Collider2D other)
    {
		Debug.Log ("Leaving collision");
		collided = false;
		topC = false;
		botC = false;
		rightC = false;
		leftC = false;
		topMax = 0f;
		botMax = 0f;
		rightMax = 0f;
		leftMax = 0f;
	}
}

using UnityEngine; // 41 Post - Created by DimasTheDriver on Dec/12/2011 . Part of the 'Unity: How to create a speech balloon' post. Available at: http://www.41post.com/?p=4545 
using System.Collections;

[ExecuteInEditMode]
public class SpeechBubble : MonoBehaviour
{
    public enum SpeechType
    {
        kWedge = 0,
        kMiniBubble = 1
    };
    //this game object's transform
    private Transform goTransform;
    //the game object's position on the screen, in pixels
    private Vector3 goScreenPos;
    //the game objects position on the screen
    private Vector3 goViewportPos;

    private Vector3 topRightOfObject;

    //the width of the speech bubble
    public int bubbleWidth = 200;
    //the height of the speech bubble
    public int bubbleHeight = 100;

    //an offset, to better position the bubble 
    public float offsetX = 0;
    public float offsetY = 150;

    //an offset to center the bubble 
    private int centerOffsetX;
    private int centerOffsetY;

    //a material to render the triangular part of the speech balloon
    public Material mat;
    //a guiSkin, to render the round part of the speech balloon
    public GUISkin guiSkin;
    public Camera camera;
    public string displayText = "Hello there! Please save me!";
    public SpeechType type;

    //use this for early initialization
    void Awake()
    {
        //get this game object's transform
        goTransform = this.GetComponent<Transform>();
    }

    //use this for initialization
    void Start()
    {
        //if the material hasn't been found
        if (!mat)
        {
            Debug.LogError("Please assign a material on the Inspector.");
            return;
        }

        //if the guiSkin hasn't been found
        if (!guiSkin)
        {
            Debug.LogError("Please assign a GUI Skin on the Inspector.");
            return;
        }

        //Calculate the X and Y offsets to center the speech balloon exactly on the center of the game object
        centerOffsetX = bubbleWidth / 2;
        centerOffsetY = bubbleHeight / 2;
    }


    //Called once per frame, after the update
    void LateUpdate()
    {
        //find out the position on the screen of this game object
        goScreenPos = camera.WorldToScreenPoint(goTransform.position);

        topRightOfObject = camera.WorldToScreenPoint(goTransform.GetComponent<SpriteRenderer>().bounds.max);

        //Could have used the following line, instead of lines 70 and 71
        goViewportPos = camera.WorldToViewportPoint(goTransform.position);
        //goViewportPos.x = goScreenPos.x / (float)Screen.width;
        //goViewportPos.y = goScreenPos.y / (float)Screen.height;
    }

    //Draw GUIs
    void OnGUI()
    {
        if (renderer.isVisible && !NpcDialogue.playerTalking)
        {
            //Begin the GUI group centering the speech bubble at the same position of this game object. After that, apply the offset
            GUI.BeginGroup(new Rect(goScreenPos.x - centerOffsetX - offsetX, Screen.height - goScreenPos.y - centerOffsetY - offsetY, bubbleWidth, bubbleHeight));

            //Render the round part of the bubble
            GUI.Label(new Rect(0, 0, bubbleWidth, bubbleHeight), "", guiSkin.customStyles[0]);

            //Render the text
            Rect mainBubbleRect = new Rect(bubbleWidth * 0.2f, bubbleHeight * 0.2f, bubbleWidth * 0.8f, bubbleHeight * 0.8f);
            GUI.Label(mainBubbleRect, displayText, guiSkin.label);

            //Vector2 mainBubbleLowerRight = new Vector2(mainBubbleRect.xMax, mainBubbleRect.yMin);
            //Vector2 topRightOfObject = new Vector2(topOfObject.x, topOfObject.y);
            //Vector2 totalVector = mainBubbleLowerRight - topRightOfObject;

            //Vector2 miniBubblePosition = mainBubbleLowerRight - (0.5f * totalVector);
            //Vector2 miniBubbleSize = new Vector2(bubbleWidth / 4, bubbleHeight / 4);



            //GUI.Label(new Rect(topOfObject.x, Screen.height - topOfObject.y, bubbleWidth / 4, bubbleHeight / 4), "", guiSkin.customStyles[0]);
            //GUI.Label(new Rect(miniBubblePosition.x - (miniBubbleSize.x / 2), Screen.height - miniBubblePosition.y - (miniBubbleSize.y / 2), miniBubbleSize.x, miniBubbleSize.y), "", guiSkin.customStyles[0]);

            GUI.EndGroup();

            if (type == SpeechType.kMiniBubble)
            {
                Vector2 mainBubbleLowerRight = new Vector2(goScreenPos.x - centerOffsetX - offsetX + mainBubbleRect.xMin + (mainBubbleRect.width * 0.5f), Screen.height - goScreenPos.y - centerOffsetY - offsetY + mainBubbleRect.yMin);
                Vector2 totalVector = mainBubbleLowerRight - new Vector2(topRightOfObject.x, topRightOfObject.y);

                for (int i = 1; i <= 3; ++i)
                {
                    Vector2 miniBubblePosition = mainBubbleLowerRight - ((i / 3.0f) * totalVector);
                    Vector2 miniBubbleSize = new Vector2(bubbleWidth * ((3 - i) / 10.0f), bubbleHeight * ((3 - i) / 10.0f));
                    GUI.Label(new Rect(miniBubblePosition.x - (miniBubbleSize.x / 2), Screen.height - miniBubblePosition.y + (miniBubbleSize.y / 2), miniBubbleSize.x, miniBubbleSize.y), "", guiSkin.customStyles[0]);
                }
            }

            //GUI.BeginGroup(new Rect(goScreenPos.x - centerOffsetX - offsetX, Screen.height - goScreenPos.y - centerOffsetY - offsetY, bubbleWidth, bubbleHeight));
            //GUI.EndGroup();
        }
    }

    //Called after camera has finished rendering the scene
    void OnRenderObject()
    {
        //if (UnityEditor.SceneView.currentDrawingSceneView == null)
        {
            if (renderer.isVisible && !NpcDialogue.playerTalking && type == SpeechType.kWedge)
            {
                //push current matrix into the matrix stack
                GL.PushMatrix();
                //set material pass
                mat.SetPass(0);
                //load orthogonal projection matrix
                GL.LoadOrtho();
                //a triangle primitive is going to be rendered
                GL.Begin(GL.TRIANGLES);

                //set the color
                GL.Color(Color.white);

                //Define the triangle vetices
                GL.Vertex3(goViewportPos.x, goViewportPos.y + (offsetY / 3) / Screen.height, 0.1f);
                GL.Vertex3(goViewportPos.x - (bubbleWidth / 3) / (float)Screen.width, goViewportPos.y + offsetY / Screen.height, 0.1f);
                GL.Vertex3(goViewportPos.x - (bubbleWidth / 8) / (float)Screen.width, goViewportPos.y + offsetY / Screen.height, 0.1f);

                GL.End();
                //pop the orthogonal matrix from the stack
                GL.PopMatrix();
            }
        }
    }
}
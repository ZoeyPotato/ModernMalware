//This class defines behavior for the Spyware ranged enemy. This class could be
//abstracted out to another abstract enemy type (EnemyRanged) but this will
//probably be the only ranged enemy, so I didn't bother.

using UnityEngine;
using System.Collections;


public class Spyware : Enemy
{
    protected enum SpywareState
    {
        Idle = 0,
        Preparing = 1,
        Attacking = 2,
        Chasing = 3,
        Fleeing = 4
    };
    private SpywareState curState;    

    public float HitPointFleeTrigger = 2f;   //HitPoint value required to cause spyware to flee

    public GameObject Projectile = null;   //reference to a Projectile prefab gameobject


    protected void Reset()
    {      
        TotalHitPoints = 5;
        CurHitPoints = TotalHitPoints;
        AttackDamage = 2;
        AttackRange = 6f;
        AggroRange = 5f;
        AttackCD = 1.5f;
        WindupTimer = 1.5f;
        Speed = 2.5f;
        MaxSpeed = Speed;
        SpeedVariance = 0.5f;
    }

	protected override void Start()
	{
        if (Transform == null)
            Transform = this.GetComponent<Transform>();                

        if (Animation == null)
            Animation = this.GetComponent<Animator>();        

        curState = SpywareState.Idle;

        base.Start();
	}
	
	
	protected override void Update()
	{
        //if our hit points are ever low enough to flee, and we are out of
        //attack range, then flee!        
        if (TotalHitPoints <= HitPointFleeTrigger && DistToHero() <= AttackRange)
            curState = SpywareState.Fleeing;

        Animation.enabled = true;

        if (isStunned == true)
        {
            curState = SpywareState.Idle;
            Stunned();
        }

        //switch and execute behavior based on current state
        if (isStunned == false)
        {
            switch (curState)
            {
                case SpywareState.Idle:
                    UpdateInIdle();
                    break;

                case SpywareState.Preparing:
                    UpdateInPreparing();
                    break;

                case SpywareState.Attacking:
                    UpdateInAttacking();
                    break;

                case SpywareState.Chasing:
                    UpdateInChasing();
                    break;

                case SpywareState.Fleeing:
                    UpdateInFleeing();
                    break;
            }
        }

        base.Update();
	}


    private void UpdateInIdle()
    {
        //by default, spyware wander around when considered idle
        //base.Wander();

        Animation.enabled = false;

        //if we are within AggroRange, prepare for an attack
        if (DistToHero() <= AggroRange)
        {
            curState = SpywareState.Preparing;
            isAggroed = true;
        }
    }

    private void UpdateInPreparing()
    {
        Animation.enabled = true;

        //go to normal enemy animation while preparing
        GoToAniState("Preparing");

        //wait and prepare for the next attack. Only attack if we have waited the attack cd
        if ((Time.realtimeSinceStartup - CurAttackCD) > AttackCD)
        {
            CurWindupTimer = Time.realtimeSinceStartup;   //prepare windup timer
            
            //go to attacking state, wind up and attack
            curState = SpywareState.Attacking;
        }
    }

    private void UpdateInAttacking()
    {
        //attack in the correct direction relative to player
        AnimateMeleeOrRangedAttack(1);

        //if we have completed waiting our windup timer, then attack
        if ((Time.realtimeSinceStartup - CurWindupTimer) > WindupTimer)
        {
            //shoot a projectile to player if player is in range of attack
            if (DistToHero() <= AttackRange)
            {
                GameObject curProjectile = Instantiate(Projectile) as GameObject;
                SoundEffectsHelper.Instance.MakeEnemyFireSound();
                curProjectile.transform.position = Transform.position;
                curProjectile.transform.up = (PlayerTransform.position - Transform.position);
                curProjectile.GetComponent<Projectile>().Damage = AttackDamage;
            }

            CurAttackCD = Time.realtimeSinceStartup;   //reset the attack CD timer
            
            //go to preparing state and wait for next attack
            curState = SpywareState.Preparing;
        }        

        //go to chasing state if the hero runs out of attack range
        if (DistToHero() > AttackRange)
        {
            curState = SpywareState.Chasing;
            isAggroed = false;
        }
    }

    private void UpdateInChasing()
    {        
        //move in the direction of the player                
        Vector3 dirToPlayer = PlayerTransform.position - Transform.position;
        Vector3 velocity = dirToPlayer.normalized * Speed;

        Transform.Translate(velocity * Time.deltaTime, Space.World);

        //determine which direction animation to call based on where we went
        AnimateMovement(velocity);        

        //if we are within AggroRange, toggle to preparing
        if (DistToHero() <= AggroRange)
        {
            curState = SpywareState.Preparing;
            isAggroed = true;
        }
    }

    private void UpdateInFleeing()
    {
        //while fleeing, run away from the player
        //move away from the player
        Vector3 dirAwayFromPlayer = Transform.position - PlayerTransform.position;
        Vector3 velocity = dirAwayFromPlayer.normalized * Speed;

        Transform.Translate(velocity * Time.deltaTime, Space.World);

        //determine which direction animation to call based on where we went
        AnimateMovement(velocity);

        //insert code to not collide with objects and world
        //TODO:

        //if we are out of attackrange, toggle back to idle
        if (DistToHero() > AttackRange)
            curState = SpywareState.Idle;
    }


    protected override void OnTriggerEnter2D(Collider2D other)
    {
        base.OnTriggerEnter2D(other);
    }
}

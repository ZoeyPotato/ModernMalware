//This class defines behavior for the worm ambusher enemy. This class could
//possibly be abstracted out to another abstract enemy type (Wormy) but this will
//probably be the worm/ambusher, so I didn't bother.

using UnityEngine;
using System.Collections;


public class Worm : Enemy
{
    protected enum WormState
    {
        Idle = 0,
        Preparing = 1,
        Burrowing = 2,
        Burrowed = 3,
        Unburrowing = 4,
        Attacking = 5,
        Annoying = 6
    };
    private WormState curState;

    public float UnBurrowRange = 0.5f;   //range from player until worm unburrows

    public float AttackTimer = 1.5f;   //how long to animate the attack animation
    private float curAttackTimer;   //amount of time passed while animating attack

    public float BurrowedSpeed = 6f;   //speed of the worm while burrowed
    
    public float HitPointAnnoyTrigger = 1f;   //HitPoint value required to cause worm to flee


    protected void Reset()
    {                
        TotalHitPoints = 8;
        CurHitPoints = TotalHitPoints;
        AttackDamage = 6;
        AttackRange = 0.5f;
        AggroRange = 5;
        AttackCD = 3f;   //total amount of time to wait before reburrowing after attacking
        WindupTimer = 1f;   //amount of time it takes to burrow and unburrow
        Speed = 1.5f;
        MaxSpeed = Speed;
        SpeedVariance = 0.5f;
    }


	protected override void Start()
	{
        if (Transform == null)
            Transform = this.GetComponent<Transform>();

        curState = WormState.Idle;

        curAttackTimer = Time.realtimeSinceStartup;

        if (Animation == null)
            Animation = this.GetComponent<Animator>();        

        base.Start();
	}
	
	
	protected override void Update()
	{
        //if our hit points are ever low enough to be annoying, then be annoying!      
        //if (TotalHitPoints <= HitPointAnnoyTrigger)
            //curState = WormState.Annoying;

        Animation.enabled = true;

        if (isStunned == true)
        {
            curState = WormState.Idle;
            Stunned();
        }

        //switch and execute behavior based on current state
        if (isStunned == false)
        {
            switch (curState)
            {
                case WormState.Idle:
                    UpdateInIdle();
                    break;

                case WormState.Preparing:
                    UpdateInPreparing();
                    break;

                case WormState.Burrowing:
                    UpdateInBurrowing();
                    break;

                case WormState.Burrowed:
                    UpdateInBurrowed();
                    break;

                case WormState.Unburrowing:
                    UpdateInUnburrowing();
                    break;

                case WormState.Attacking:
                    UpdateInAttacking();
                    break;

                case WormState.Annoying:
                    UpdateInAnnoying();
                    break;
            }
        }

        base.Update();
	}


    private void UpdateInIdle()
    {
        //by default, worm wander around when considered idle
        //base.Wander();

        Animation.enabled = false;

        //if we are within AggroRange, prepare to burrow
        if (DistToHero() <= AggroRange)
        {
            curState = WormState.Preparing;
            isAggroed = true;
        }
    }

    private void UpdateInPreparing()
    {
        //move away from the player
        Vector3 dirToPlayer = Transform.position - PlayerTransform.position;
        Vector3 velocity = dirToPlayer.normalized * Speed;

        Transform.Translate(velocity * Time.deltaTime, Space.World);

        //determine which direction animation to call based on where we went
        AnimateMovement(velocity);

        //wait and prepare for the next burrowing. Only burrow if we have waited the attack cd
        if ((Time.realtimeSinceStartup - CurAttackCD) > AttackCD)
        {
            CurWindupTimer = Time.realtimeSinceStartup;   //prepare burrowing timer

            //go to burrowing state
            curState = WormState.Burrowing;
        }
    }

    private void UpdateInBurrowing()
    {
        //set animation to burrowing        
        GoToAniState("Burrowing");

        //if we have completed waiting our burrowing timer, then finally burrow
        if ((Time.realtimeSinceStartup - CurWindupTimer) > WindupTimer)
        {
            //go to burrowed state, start traveling to player
            curState = WormState.Burrowed;
        }
    }

    private void UpdateInBurrowed()
    {
        //move towards the player at BurrowedSpeed
        Vector3 dirToPlayer = PlayerTransform.position - Transform.position;
        Vector3 velocity = dirToPlayer.normalized * BurrowedSpeed;

        Transform.Translate(velocity * Time.deltaTime, Space.World);
        
        //go to burrowed moving animation
        GoToAniState("Burrowed");

        //if the worm reaches range to attack, then start unburrowing        
        if (DistToHero() <= UnBurrowRange)
        {
            CurWindupTimer = Time.realtimeSinceStartup;   //prepare unburrowing timer

            curState = WormState.Unburrowing;
        }
    }

    private void UpdateInUnburrowing()
    {
        //set animation to unburrowing
        GoToAniState("Unburrowing");

        //if we have completed waiting our unburrowing timer, then finally attack
        if ((Time.realtimeSinceStartup - CurWindupTimer) > WindupTimer)
        {
            //if the player is within attackrange at this time, deal damage
            if (DistToHero() <= AttackRange)
                Player.Instance.gameObject.GetComponent<Health>().CurHitPoints -= AttackDamage;

            curAttackTimer = Time.realtimeSinceStartup;   //prepare attack animation timer

            //go to attack state, mainly to animate the attack
            curState = WormState.Attacking;
        }
    }

    private void UpdateInAttacking()
    {
        //set animation to attacking
        GoToAniState("Attacking");

        //if we have completed waiting our attacking timer, then either idle or
        //prepare to burrow again, depending on if the player is in aggro range
        if ((Time.realtimeSinceStartup - curAttackTimer) > AttackTimer)
        {
            CurAttackCD = Time.realtimeSinceStartup;   //reset the attack/burrow CD timer

            //go to idle state, see if player is still in aggro range
            curState = WormState.Idle;
        }
    }

    private void UpdateInAnnoying()
    {
        //When the worm is on low health, the worm will burrow on when its burrow cd is up
        //When burrowed in low health, move to random locations and be annoying.
        //Pop up at different times (basically ambush the random locations you go to). 
    }


    protected override void OnTriggerEnter2D(Collider2D other)
    {
        base.OnTriggerEnter2D(other);
    }
}

using UnityEngine;
using System.Collections;


public abstract class EnemyMeleeChaser : Enemy
{
    protected enum MeleeChaserState
    {
        Idle = 0,
        Chasing = 1,
        Attacking = 2
    };
    private MeleeChaserState curState;

    #region Collision
    private Vector3 newPos;
    private float topMax, botMax, rightMax, leftMax;
    private bool collided, topC, botC, rightC, leftC = false;
    #endregion


	protected override void Start()
	{        
        curState = MeleeChaserState.Idle;        

        base.Start();
	}


    protected override void Update()
	{
        Animation.enabled = true;

        if (isStunned == true)
        {
            curState = MeleeChaserState.Idle;
            Stunned();            
        }

        //switch and execute behavior based on current state
        if (isStunned == false)
        {
            switch (curState)
            {
                case MeleeChaserState.Idle:
                    UpdateInIdle();
                    break;

                case MeleeChaserState.Chasing:
                    UpdateInChasing();
                    break;

                case MeleeChaserState.Attacking:
                    UpdateInAttacking();
                    break;
            }
        }

        base.Update();
	}


    protected virtual void UpdateInIdle()
    {
        //by default, melee chasers wander around when considered idle
        //base.Wander();

        Animation.enabled = false;

        //if we are within AggroRange, toggle to chasing
        if (DistToHero() <= AggroRange)
        {
            curState = MeleeChaserState.Chasing;
            isAggroed = true;
        }
    }

    protected virtual void UpdateInChasing()
    { 
        //move in the direction of the player                
        Vector3 dirToPlayer = PlayerTransform.position - Transform.position;
        Vector3 velocity = dirToPlayer.normalized * Speed;

		newPos = transform.position;
		newPos += velocity * Time.deltaTime; 
		if(collided)
			checkCollision();
		transform.position = newPos;
		//Transform.Translate(velocity * Time.deltaTime, Space.World);

        //determine which direction animation to call based on where we went
        AnimateMovement(velocity);

        //if we are out of AggroRange, toggle back to idle        
        if (DistToHero() > AggroRange)
        {
            curState = MeleeChaserState.Idle;
            isAggroed = false;
        }
    }

    protected virtual void UpdateInAttacking()
    {        
        //attack in the correct direction relative to player
        AnimateMeleeOrRangedAttack(0);

        //if we have completed waiting our windup timer, then attack
        if ((Time.realtimeSinceStartup - CurWindupTimer) > WindupTimer)
        {            
            //deal damage to player if player is in range of attack
            if (DistToHero() <= AttackRange)
                Player.Instance.gameObject.GetComponent<Health>().CurHitPoints -= AttackDamage;

            Debug.Log("should have dealt damage to player");

            CurAttackCD = Time.realtimeSinceStartup;   //reset the attack CD timer

            //go back to chasing state after attacking
            curState = MeleeChaserState.Chasing;
        }
    }


    protected override void OnTriggerEnter2D(Collider2D other)
    {
		collided = true;

        //if we run into the player, and our attack is off cd, then enter attack state
        if (other.gameObject.name == "Player")
        {
            if ((Time.realtimeSinceStartup - CurAttackCD) > AttackCD)
            {                
                CurWindupTimer = Time.realtimeSinceStartup;   //prepare windup timer

                curState = MeleeChaserState.Attacking;
            }

			CollideWithObject(ref other);
        }
		if (other.gameObject.name == "Trojan" || other.gameObject.name == "CorruptedFile" || other.gameObject.name == "Worm" || other.gameObject.name == "Spyware"){
			CollideWithEnemy(ref other);
		}

        base.OnTriggerEnter2D(other);
	}

    void OnTriggerStay2D(Collider2D other)
    {
        collided = true;

        //if we still next to the player, and our attack is off cd, and we currently
        //are not attacking, then enter the attack state
        if (other.gameObject.name == "Player")
        {
            if ((Time.realtimeSinceStartup - CurAttackCD) > AttackCD)
            {
                if (curState != MeleeChaserState.Attacking)
                {
                    CurWindupTimer = Time.realtimeSinceStartup;   //prepare windup timer

                    curState = MeleeChaserState.Attacking;
                }
            }

            CollideWithObject(ref other);
        }
		if (other.gameObject.name == "Trojan" || other.gameObject.name == "CorruptedFile" || other.gameObject.name == "Worm" || other.gameObject.name == "Spyware"){
			CollideWithEnemy(ref other);
		}
    }
	
	void OnTriggerExit2D(Collider2D other)
    {
		collided = false;
		topC = false;
		botC = false;
		rightC = false;
		leftC = false;
		topMax = 0f;
		botMax = 0f;
		rightMax = 0f;
		leftMax = 0f;
	}	


    //sets the appropriate melee attack animation for the melee enemy relative
    //to the current player position (below, above, etc.)
    private void animateMeleeAttack()
    {
        float diffInX = Mathf.Abs(Transform.position.x - PlayerTransform.position.x);
        float diffInY = Mathf.Abs(Transform.position.y - PlayerTransform.position.y);

        //if we are left of the player, we need to melee right
        if (Transform.position.x < PlayerTransform.position.x)   //check if we are left
        {
            //ensure we are more left than above or below
            if (diffInX > diffInY)
                GoToAniState("Melee_Right");
        }

        //if we are right of the player, we need to melee left
        if (Transform.position.x > PlayerTransform.position.x)   //check if we are right
        {
            //ensure we are more right than above or below
            if (diffInX > diffInY)
                GoToAniState("Melee_Left");
        }

        //if we are below the player, we need to melee up
        if (Transform.position.y < PlayerTransform.position.y)   //check if we are below
        {
            //ensure we are more below than left or right
            if (diffInY >= diffInX)
                GoToAniState("Melee_Up");
        }

        //if we are above the player, we need to melee down
        if (Transform.position.y > PlayerTransform.position.y)   //check if we are above
        {
            //ensure we are more above than left or right
            if (diffInY >= diffInX)
                GoToAniState("Melee_Down");
        }
    }


    #region Collision Functions
    void checkCollision()
    {
        if (topC && botC)
        {
            if (rightC && newPos.x < rightMax)
            {
                newPos.x = rightMax;
            }
            if (leftC && newPos.x > leftMax)
            {
                newPos.x = leftMax;
            }
            return;
        }
        if (rightC && leftC)
        {
            if (topC && newPos.y > topMax)
            {
                newPos.y = topMax;
            }
            if (botC && newPos.y < botMax)
            {
                newPos.y = botMax;
            }
            return;
        }
        if (topC && newPos.y > topMax)
        {
            newPos.y = topMax;
        }
        if (botC && newPos.y < botMax)
        {
            newPos.y = botMax;
        }
        if (rightC && newPos.x < rightMax)
        {
            newPos.x = rightMax;
        }
        if (leftC && newPos.x > leftMax)
        {
            newPos.x = leftMax;
        }
    }

    void CollideWithObject(ref Collider2D other)
    {
        Bounds myBounds = GetComponent<Renderer>().bounds;
        Bounds otherBounds;
        if (other.name == "Wall")
        {
            otherBounds = other.transform.FindChild("WallRender").GetComponent<SpriteRenderer>().bounds;
        }
        else
        {
            otherBounds = other.gameObject.GetComponent<Renderer>().bounds;
        }

        Vector3 newPosition = transform.position;
		float offset = 0f;
		if (other.gameObject.name == "Trojan" || other.gameObject.name == "CorruptedFile" || other.gameObject.name == "Worm" || other.gameObject.name == "Spyware"){
			offset = 0.25f;
        }
        else if (other.gameObject.name == "Player")
        {
            offset = 0.45f;
        }
        float top = (myBounds.max.y - otherBounds.min.y);
        float bot = (otherBounds.max.y - myBounds.min.y);
        float left = (myBounds.max.x - otherBounds.min.x);
        float right = (otherBounds.max.x - myBounds.min.x);
        float min = Mathf.Min(top, bot, left, right);

        if (min == top)
        {
            //Debug.Log("Hit from below\n" );
            topC = true;
            //if (topMax == 0 || topMax < otherBounds.min.y - myBounds.extents.y)
            if (other.gameObject.name == "Player")
                topMax = otherBounds.min.y - myBounds.extents.y + 0.05f;
            else
                botMax = otherBounds.max.y + myBounds.extents.y + offset;
        } 
        if (min == bot)
        {
            //Debug.Log("Hit from above\n");
            botC = true;
            //if (botMax == 0 ||botMax > otherBounds.max.y + myBounds.extents.y)
            if  (other.gameObject.name == "Player")
                botMax = otherBounds.max.y + myBounds.extents.y - 0.05f;
            else 
                botMax = otherBounds.max.y + myBounds.extents.y - offset;
        } 
        if (min == right)
        {
            //Debug.Log("Hit from right\n");
            rightC = true;
            //if (rightMax == 0 || rightMax > otherBounds.max.x + myBounds.extents.x)
            rightMax = otherBounds.max.x + myBounds.extents.x - offset;
        } 
        if (min == left)
        {
            //Debug.Log("Hit from left\n");
            leftC = true;
            //if (leftMax == 0 || leftMax < otherBounds.min.x - myBounds.extents.x)
            leftMax = otherBounds.min.x - myBounds.extents.x + offset;
        }
    }
	void CollideWithEnemy(ref Collider2D other)
	{
		if(transform.position.x - other.transform.position.x > 5 || transform.position.x - other.transform.position.x < -5){
			//do something
		}
	}
    #endregion
}

using UnityEngine;
using System.Collections;
using System.Collections.Generic;


public abstract class Enemy : MonoBehaviour
{
	public bool IsBoss = false;		//whether the instance is the boss

    public int TotalHitPoints = 3;   //total number of hit points/life
    public int CurHitPoints = 3;   //current number of hit points    

    public int AttackDamage = 1;   //how much damage to deal per attack    

    public float AttackRange = 2f;   //maximum distance for attack to hit
    public float AggroRange = 5f;   //distance before enemy notices hero

    public float AttackCD = 1.5f;   //total amount of time to wait between attacks
    protected float CurAttackCD;   //amount of time passed since last attack
    public float WindupTimer = 0.5f;   //amount of time to 'Windup' before hitting
    protected float CurWindupTimer;   //amount of time passed since we started winding up

    public float Speed = 2f;   //dynamic runtime speed that can change
    public float SpeedVariance = .75f;   //variance in MaxSpeed, random val between +- this value
    protected float MaxSpeed;   //maximum speed that doesn't change, set to Speed in cstor

    private static GameObject player = null;
    protected static Transform PlayerTransform = null;

    protected Transform Transform = null;
    protected Animator Animation = null;

    public bool isAggroed = false;

    public static List<Enemy> enemies = new List<Enemy>();
    
    private static Color flashColor = Color.red;
    private Color originalColor = Color.white;
    private bool isFlashing = false;
    
    protected bool isStunned = false;
    public float StunnedTimer = 0.5f;   //amount of time to be stunned for
    protected float CurStunnedTimer;   //amount of time passed since we were stunned
    
    
    protected virtual void Start()
    {
        enemies.Add(this);
        CurHitPoints = TotalHitPoints;

        CurAttackCD = Time.realtimeSinceStartup;
        CurWindupTimer = Time.realtimeSinceStartup;
        CurStunnedTimer = Time.realtimeSinceStartup;

        MaxSpeed = Speed;
        Speed = Speed + Random.Range(-SpeedVariance, SpeedVariance);

        if (player == null)
        {
            player = GameObject.Find("Player");
            PlayerTransform = player.GetComponent<Transform>();
        }        
    }


    protected virtual void Update()
    {
        //if we are out of life, die
        if (CurHitPoints <= 0)
        {
			Debug.Log(name + "Just died, collision should end");
			Player.Instance.collided = false;
			SoundEffectsHelper.Instance.MakeExplosionSound();
            SpecialEffectsHelper.Instance.explosionEffect.startColor = originalColor;
            Bounds otherBounds = gameObject.GetComponent<Renderer>().bounds;
            SpecialEffectsHelper.Instance.Explosion(otherBounds.min + (otherBounds.extents / 2));
            
            //if we are the boss, then go to win screen
            if (IsBoss) 
            {
				Application.LoadLevel ("Win");
				FirstGameManager.TheGameState.SetCurrentLevel ("Win");
				FirstGameManager.TheGameState.PrintCurrentLevel ();
			}

			Destroy(this.gameObject);
        }

        if (IsBoss)
        {
            Global.Instance.isOnBoss = isAggroed;
        }
    }


    protected void Wander()
    {
        //functionality for enemies to wander around randomly
        //insert wandering idle movement...
    }

    
    protected float DistToHero()
    {
        return Vector3.Distance(Transform.position, PlayerTransform.position);
    }


    protected void GoToAniState(string AniState)
    {
        //get the animation state info from the 'Base' layer (layer 0)
        AnimatorStateInfo curAniBaseState = Animation.GetCurrentAnimatorStateInfo(0);

        //prepend 'Base.' to passed string. Assumes the state is in 'Base' layer
        string AniStateInBase = "Base." + AniState;

        //if the current ani state of the base doesn't match what we want to go to
        //then we will trigger and go to that state
        if (curAniBaseState.IsName(AniStateInBase) == false)
            Animation.SetTrigger(AniState);

        //if we are already in the state we want to go to, we do nothing
        //this lets the animation keep looping and playing out
    }

    //sets the appropriate moving animation for the enemy based on a vector
    protected void AnimateMovement(Vector3 directionOfMovement)
    {
        directionOfMovement.Normalize();
        float xDir = directionOfMovement.x;
        float yDir = directionOfMovement.y;        

        //moving in neg x dir while y is clamped between -.5 and .5
        if (xDir < 0 && yDir < 0.5 && yDir > -0.5)
            GoToAniState("Moving_Left");

        //moving in pos x dir while y is clamped between -.5 and .5
        if (xDir > 0 && yDir < 0.5 && yDir > -0.5)
            GoToAniState("Moving_Right");
        
        if (yDir >= 0.5)
            GoToAniState("Moving_Up");
        
        if (yDir <= -0.5)
            GoToAniState("Moving_Down");
    }

    //sets the appropriate melee or ranged attack animation for the melee enemy 
    //relative to the current player position (below, above, etc.)
    //a passed int of 0 is defined as melee, 1 range
    protected void AnimateMeleeOrRangedAttack(int MeleeOrRange)
    {
        float diffInX = Mathf.Abs(Transform.position.x - PlayerTransform.position.x);
        float diffInY = Mathf.Abs(Transform.position.y - PlayerTransform.position.y);

        //if we are left of the player, we need to melee right
        if (Transform.position.x < PlayerTransform.position.x)   //check if we are left
        {
            //ensure we are more left than above or below
            if (diffInX > diffInY)
            {
                if (MeleeOrRange == 0)
                    GoToAniState("Melee_Right");
                if (MeleeOrRange == 1)
                    GoToAniState("Ranged_Right");
            }
        }

        //if we are right of the player, we need to melee left
        if (Transform.position.x > PlayerTransform.position.x)   //check if we are right
        {
            //ensure we are more right than above or below
            if (diffInX > diffInY)
            {
                if (MeleeOrRange == 0)
                    GoToAniState("Melee_Left");
                if (MeleeOrRange == 1)
                    GoToAniState("Ranged_Left");
            }
        }

        //if we are below the player, we need to melee up
        if (Transform.position.y < PlayerTransform.position.y)   //check if we are below
        {
            //ensure we are more below than left or right
            if (diffInY >= diffInX)
            {
                if (MeleeOrRange == 0)
                    GoToAniState("Melee_Up");
                if (MeleeOrRange == 1)
                    GoToAniState("Ranged_Up");
            }
        }

        //if we are above the player, we need to melee down
        if (Transform.position.y > PlayerTransform.position.y)   //check if we are above
        {
            //ensure we are more above than left or right
            if (diffInY >= diffInX)
            {
                if (MeleeOrRange == 0)
                    GoToAniState("Melee_Down");
                if (MeleeOrRange == 1)
                    GoToAniState("Ranged_Down");
            }
        }
    }


    public IEnumerator FlashMe(float time, float intervalTime)
    {
        float elapsedTime = 0f;
        int index = 0;
        if (!isFlashing)
        {
            isFlashing = true;
            originalColor = GetComponent<SpriteRenderer>().color;
            while (elapsedTime < time)
            {
				if (!isFlashing || this == null)
					yield return null;

                SpriteRenderer rend = GetComponent<SpriteRenderer>();
                if (rend != null)
                {
                	if (index % 2 == 0)
                    	rend.color = originalColor;
                	else
                    	rend.color = flashColor;
                }

                elapsedTime += Time.deltaTime;
                index++;
                yield return new WaitForSeconds(intervalTime);
            }
			SpriteRenderer blargh = GetComponent<SpriteRenderer>();
			if (blargh != null){
            	GetComponent<SpriteRenderer>().color = originalColor;
			}
            isFlashing = false;
        }
    }

    public void SetToStun()
    {
        //only go to stunned state if we have waited the stun timer out
        if ((Time.realtimeSinceStartup - CurStunnedTimer) > StunnedTimer)
        {
            CurStunnedTimer = Time.realtimeSinceStartup;   //prepare stunned timer

            isStunned = true;
        }
    }

    public void Stunned()
    {
        //Debug.Log("should be in stunned state");
        Speed = 0;

        Animation.enabled = false;

        //if we have completed waiting our stunned timer, then stop being stunned
        if ((Time.realtimeSinceStartup - CurStunnedTimer) > StunnedTimer)
        {                 
            CurStunnedTimer = Time.realtimeSinceStartup;   //reset the stunned timer

            Speed = MaxSpeed + Random.Range(-SpeedVariance, SpeedVariance);

            //reset the stunned flag, all enemies should respond accordingly
            isStunned = false;
        }
    }

    
    protected virtual void OnTriggerEnter2D(Collider2D other)
    {
        if (other.name == "ProjectilePlayer(Clone)")
        {
            Destroy(other.gameObject);
            SoundEffectsHelper.Instance.MakeHitSound();
            CurHitPoints -= other.GetComponent<Projectile>().Damage;
            Global.Instance.SpawnPoint(other.GetComponent<Projectile>().Damage, transform.position);
            StartCoroutine(FlashMe(0.2f, 0.1f));
        }
		if (other.name == "BitPet" && !IsBoss && isAggroed){
			SetToStun();
		}else if(!isAggroed && other.name == "BitPet") {
			Debug.Log("wtfisthisI don't even");
			BitPet bit = GameObject.Find("BitPet").GetComponent<BitPet>();
			bit.attacking = false;
			Speed = MaxSpeed;
		}
    }

	protected virtual void OnTriggerStay2D(Collider2D other)
	{
		if (other.name == "BitPet" && !IsBoss && isAggroed){
			SetToStun();
		}else if(!isAggroed && other.name == "BitPet") {
			Debug.Log("wtfisthisI don't even");
			BitPet bit = GameObject.Find("BitPet").GetComponent<BitPet>();
			bit.attacking = false;
			Speed = MaxSpeed;
		}
	}

    public void OnDestroy()
    {
        enemies.Remove(this);
        isFlashing = false;
        StopAllCoroutines();
        //StopCoroutine ("FlashMe");
    }
}
